use std::{path::Path, sync::Arc};

use tracing::{info, trace};

use crate::utils::{
    file::FileType,
    stream::{StreamBuilder, mp4::MP4StreamGenerator},
};

/// Generate MP4 cache file from source video
// TODO: Instrument this and log the average time taken, separated by the various hot paths (e.g. cache miss and cache hit)
pub async fn generate_mp4_cache(
    source_path: &Path,
    output_path: &Path,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Use a static mutex map to prevent concurrent generation of the same file
    use std::collections::HashMap;
    use std::sync::OnceLock;
    use tokio::sync::Mutex;

    type LocksMap = HashMap<String, Arc<Mutex<()>>>; // TODO: Replace this with distributed lock and maybe move this into a worker service outright (outside of beam-stream)
    static GENERATION_LOCKS: OnceLock<Arc<Mutex<LocksMap>>> = OnceLock::new();

    let locks = GENERATION_LOCKS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())));
    let cache_key = output_path.to_string_lossy().to_string();

    // Get or create a lock for this specific cache file
    let lock = {
        let mut locks_map = locks.lock().await;
        locks_map
            .entry(cache_key.clone())
            .or_insert_with(|| Arc::new(Mutex::new(())))
            .clone()
    };

    // Acquire the lock - only one task can generate this file at a time
    let _guard = lock.lock().await;

    // Check again if file exists (another task might have created it while we waited)
    if output_path.exists() {
        trace!("MP4 already generated by another task: {:?}", output_path);
        return Ok(());
    }

    trace!("Starting MP4 generation in background task...");

    // Initialize FFmpeg (safe to call multiple times)
    ffmpeg_next::init()?;

    // Build stream configuration
    let mut stream_builder = StreamBuilder::new();
    stream_builder.add_file(FileType::Video, source_path);
    let stream_configuration = stream_builder.build().await?;

    // Create MP4 generator
    let mp4_generator = MP4StreamGenerator::from(stream_configuration);

    // Generate MP4 (this internally spawns a blocking task)
    mp4_generator.generate_mp4(output_path).await?;

    info!("MP4 generation completed successfully");
    Ok(())
}
